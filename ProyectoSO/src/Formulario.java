/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.PriorityQueue;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;

/**
 *
 * @author Lito Soler Kelly Aguilar María Ramírez Orlando Durán Mario Gómez
 */
public class Formulario extends javax.swing.JFrame {
    
    //Colas de prioridad (5 TDA's) para los 5 estados del Modelo
    static PriorityQueue<Proceso> colaNuevos = new PriorityQueue<>();//Nuevos
    static PriorityQueue<Proceso> colaEjecutando = new PriorityQueue<>();//Ejecutando
    static PriorityQueue<Proceso> colaListos = new PriorityQueue<>();//Listos
    static PriorityQueue<Proceso> colaBloqueados = new PriorityQueue<>();//Bloqueados
    static PriorityQueue<Proceso> colaTerminados = new PriorityQueue<>();//Terminados
    static PriorityQueue<Proceso> colaImpresion = new PriorityQueue<>();//Cola utilizada para clonar otra de las colas principales y así evitar perder el contenido de estas.

    /**
     * Creates new form Formulario
     */
    public Formulario() {
        initComponents();
        //this.setExtendedState(MAXIMIZED_BOTH);
        getContentPane().setBackground(Color.WHITE);  
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtcola0 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtcola1 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtcola2 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtcola3 = new javax.swing.JTextArea();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtcola4 = new javax.swing.JTextArea();
        btnSimulacion = new javax.swing.JButton();
        btnnueva = new javax.swing.JButton();
        btnGuardar = new javax.swing.JButton();
        lblHistorial = new javax.swing.JLabel();
        btnEjecutar = new javax.swing.JButton();
        jDesktopPane1 = new javax.swing.JDesktopPane();
        lblCantidad = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        txtHistorialEjecucion = new javax.swing.JTextArea();
        txtcantidad = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Simulador de Procesos");
        setBackground(new java.awt.Color(255, 255, 255));
        setResizable(false);
        setSize(new java.awt.Dimension(1000, 1000));

        txtcola0.setEditable(false);
        txtcola0.setColumns(10);
        txtcola0.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtcola0.setRows(5);
        txtcola0.setBorder(null);
        jScrollPane1.setViewportView(txtcola0);

        txtcola1.setEditable(false);
        txtcola1.setColumns(10);
        txtcola1.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtcola1.setRows(5);
        txtcola1.setBorder(null);
        jScrollPane2.setViewportView(txtcola1);

        txtcola2.setEditable(false);
        txtcola2.setColumns(10);
        txtcola2.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtcola2.setRows(5);
        txtcola2.setBorder(null);
        jScrollPane3.setViewportView(txtcola2);

        txtcola3.setEditable(false);
        txtcola3.setColumns(10);
        txtcola3.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtcola3.setRows(5);
        txtcola3.setBorder(null);
        jScrollPane4.setViewportView(txtcola3);

        txtcola4.setEditable(false);
        txtcola4.setColumns(10);
        txtcola4.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtcola4.setRows(5);
        jScrollPane5.setViewportView(txtcola4);

        btnSimulacion.setBackground(new java.awt.Color(0, 153, 204));
        btnSimulacion.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnSimulacion.setForeground(new java.awt.Color(255, 255, 255));
        btnSimulacion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/random.png"))); // NOI18N
        btnSimulacion.setToolTipText("Crear procesos Aleatorios");
        btnSimulacion.setBorder(null);
        btnSimulacion.setName("btnSimulacionAlea"); // NOI18N
        btnSimulacion.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btnSimulacionMouseClicked(evt);
            }
        });
        btnSimulacion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSimulacionActionPerformed(evt);
            }
        });

        btnnueva.setBackground(new java.awt.Color(0, 153, 255));
        btnnueva.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnnueva.setForeground(new java.awt.Color(255, 255, 255));
        btnnueva.setIcon(new javax.swing.ImageIcon(getClass().getResource("/open.png"))); // NOI18N
        btnnueva.setToolTipText("Cargar procesos");
        btnnueva.setBorder(null);
        btnnueva.setName("btnCargarSimulacion"); // NOI18N
        btnnueva.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnnuevaActionPerformed(evt);
            }
        });

        btnGuardar.setBackground(new java.awt.Color(102, 204, 255));
        btnGuardar.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnGuardar.setForeground(new java.awt.Color(255, 255, 255));
        btnGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/save.png"))); // NOI18N
        btnGuardar.setToolTipText("Guardar estado de Procesos");
        btnGuardar.setBorder(null);
        btnGuardar.setName("btnGuardarSimulacion"); // NOI18N
        btnGuardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGuardarActionPerformed(evt);
            }
        });

        lblHistorial.setIcon(new javax.swing.ImageIcon(getClass().getResource("/estados.png"))); // NOI18N

        btnEjecutar.setBackground(new java.awt.Color(153, 204, 255));
        btnEjecutar.setForeground(new java.awt.Color(255, 255, 255));
        btnEjecutar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/run.png"))); // NOI18N
        btnEjecutar.setToolTipText("Comenzar Simulación");
        btnEjecutar.setBorder(null);
        btnEjecutar.setEnabled(false);
        btnEjecutar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEjecutarActionPerformed(evt);
            }
        });

        jDesktopPane1.setBackground(new java.awt.Color(226, 226, 226));

        lblCantidad.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblCantidad.setIcon(new javax.swing.ImageIcon(getClass().getResource("/ciclos.png"))); // NOI18N

        txtHistorialEjecucion.setEditable(false);
        txtHistorialEjecucion.setColumns(10);
        txtHistorialEjecucion.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        txtHistorialEjecucion.setRows(5);
        txtHistorialEjecucion.setBorder(null);
        txtHistorialEjecucion.setName("txtHistorialEjecucion"); // NOI18N
        jScrollPane6.setViewportView(txtHistorialEjecucion);

        txtcantidad.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/historial.png"))); // NOI18N

        jDesktopPane1.setLayer(lblCantidad, javax.swing.JLayeredPane.DEFAULT_LAYER);
        jDesktopPane1.setLayer(jScrollPane6, javax.swing.JLayeredPane.DEFAULT_LAYER);
        jDesktopPane1.setLayer(txtcantidad, javax.swing.JLayeredPane.DEFAULT_LAYER);
        jDesktopPane1.setLayer(jLabel1, javax.swing.JLayeredPane.DEFAULT_LAYER);

        javax.swing.GroupLayout jDesktopPane1Layout = new javax.swing.GroupLayout(jDesktopPane1);
        jDesktopPane1.setLayout(jDesktopPane1Layout);
        jDesktopPane1Layout.setHorizontalGroup(
            jDesktopPane1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDesktopPane1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jDesktopPane1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblCantidad)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(txtcantidad)
                    .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jDesktopPane1Layout.setVerticalGroup(
            jDesktopPane1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDesktopPane1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lblCantidad)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(txtcantidad, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 263, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(25, 25, 25))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jDesktopPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 173, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(btnSimulacion, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(btnnueva, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(btnGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(btnEjecutar, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addComponent(lblHistorial, javax.swing.GroupLayout.Alignment.TRAILING)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(lblHistorial)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnSimulacion, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnEjecutar, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(btnnueva, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(jDesktopPane1))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //BOTON QUE SIMULA ALEATORIAMENTE
    private void btnSimulacionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSimulacionActionPerformed
       //Limpiando colas
        limpiarColas();
        //Generando procesos nuevos aleatorios 
//        System.out.println("-------------------PROCESOS A SIMULAR-----------------");
        for (int i = 0; i < 20; i++) {
            Proceso proceso = new Proceso();
            proceso.crearAleatorioBCP();
            proceso.validarProceso();
            colaNuevos.add(proceso);
//            System.out.println(proceso + "      " + proceso.getMensaje());
        }
        Proceso.ultimoId=0;
//        System.out.println("-------------------------------------------------------");        
        imprimirColas();
        btnEjecutar.setEnabled(true);
    }//GEN-LAST:event_btnSimulacionActionPerformed

    //BOTON PARA GUARDAR
    private void btnGuardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGuardarActionPerformed
        exportar();
    }//GEN-LAST:event_btnGuardarActionPerformed

    private void btnnuevaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnnuevaActionPerformed
        try {
            PriorityQueue<Proceso> todosProcesos;
            //Limpiando colas
            limpiarColas();  //Este código solo debe ejecutarse una vez, para limpiar las colas antes de leer el archivo            
            todosProcesos = obtenerProcesos("./procesos.txt");            
            while(! todosProcesos.isEmpty()){
                Proceso proceso = todosProcesos.remove();
                //Verificando si el proceso es válido, si no es válido es desechado
                if(proceso.getValidez()){
                    //Verificando en qué estado se encuentra el proceso
                    switch(proceso.getEstado()){
                        //Añadiendo a nuevos
                        case 0:
                            colaNuevos.add(proceso);
                            break;
                            //Añadiendo a listos
                        case 1:
                            colaListos.add(proceso);
                            break;
                            //Añadiendo a Ejecutando
                        case 2:
                            colaEjecutando.add(proceso);
                            break;
                            //Añadiendo a Bloqueados
                        case 3:
                            colaBloqueados.add(proceso);
                            break;
                            //Añadiendo a terminados
                        case 4:
                            colaTerminados.add(proceso);
                            break;
                    }
                }
            }
            
        } catch (IOException ex) {        
            Logger.getLogger(Formulario.class.getName()).log(Level.SEVERE, null, ex);
        }
        imprimirColas();
        btnEjecutar.setEnabled(true);
    }//GEN-LAST:event_btnnuevaActionPerformed

    private void btnSimulacionMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnSimulacionMouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_btnSimulacionMouseClicked

    private void btnEjecutarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEjecutarActionPerformed
        //Verificando si el usuario ingresó los ciclos
        if (!verificarCantCiclos()) {
            return;
        }
        //Comenzar ejecución
        if(colaListos.isEmpty() && colaNuevos.isEmpty() && colaEjecutando.isEmpty() && colaBloqueados.isEmpty()){
            JOptionPane.showMessageDialog(rootPane, "Todos los procesos han terminado.");
            return;
        }
        ejecucion();
    }//GEN-LAST:event_btnEjecutarActionPerformed

    private void exportar() {//procedimiento para guardar en un archivo de texto
        try {
//            JFileChooser archivo = new JFileChooser(System.getProperty("user.dir"));
//            archivo.showSaveDialog(this);
            String ruta = "./procesos.txt";
            File archivo = new File(ruta);
            if (archivo.exists()) {
                try (FileWriter guardado = new FileWriter(archivo)) {
                    guardado.write(txtcola0.getText() + txtcola1.getText() + txtcola2.getText() + txtcola3.getText() + txtcola4.getText());//guarda todas las colas en el archivo de texto
                    JOptionPane.showMessageDialog(rootPane, "El archivo fue guardado con éxito");
                }
            }
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage());
        }
    }
    
   private PriorityQueue<Proceso> obtenerProcesos(String archivo) throws FileNotFoundException, IOException {
      String cadena;
      String acumulador = "";
      FileReader f = new FileReader(archivo);
      BufferedReader b = new BufferedReader(f);
      while((cadena = b.readLine())!=null) {
          acumulador += cadena;
      }
      b.close();
      return crearProcesos(acumulador);
    }   
    
    public PriorityQueue<Proceso> crearProcesos(String cadena) {
        PriorityQueue<Proceso> todosProcesos = new PriorityQueue<>();
        String[] procesos = cadena.split(";");
        for(int i = 0; i <procesos.length; i++){
            String proceso = procesos[i];
            String[] partesProceso = proceso.split("/");
            int id = Integer.parseInt(partesProceso[0]);
            int estado = Integer.parseInt(partesProceso[1]);
            int prioridad = Integer.parseInt(partesProceso[2]);
            int cantidadInstruc = Integer.parseInt(partesProceso[3]);
            int intrucBloqueo = Integer.parseInt(partesProceso[4]);
            int evento = Integer.parseInt(partesProceso[5]);
            
            Proceso procesoCreado = new Proceso();
            procesoCreado.crearBCP(id,estado, prioridad,cantidadInstruc,intrucBloqueo,evento);  
            procesoCreado.validarProceso();
            todosProcesos.add(procesoCreado);  
        }
        return todosProcesos;
    }
    
    private void guardarOrdenEjecucionProcesos(String traza){
       try {
            String ruta = "./ordenEjecucion.txt";
            File archivo = new File(ruta);
           
            if (archivo.exists()) {
                try (FileWriter guardado = new FileWriter(archivo)) {
                    guardado.write(traza);
                    //JOptionPane.showMessageDialog(rootPane, "El orden de ejecucion fue guardado con exito");
                }
            }
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage());
        }
       txtHistorialEjecucion.setText(traza);
    }

    public boolean verificarCantCiclos() {
        try{
            if (Integer.parseInt(txtcantidad.getText()) > 0) {
                return true;
            }
        }catch(NumberFormatException e){
            JOptionPane.showMessageDialog(this, "Debe ingresar la cantidad de ciclos");
        }        
        return false;
    }

    public void ejecucion() {
        Integer cantidadCiclos = Integer.parseInt(txtcantidad.getText()); //Aquí se debe almacenar la cantidad de ciclos que el usuario ingresa 
        String traza = "";
        //Verificando si hay nuevos procesos 
        if (colaNuevos.isEmpty()) {
            System.out.println("No existen procesos nuevos");
        }

        //Comienzo de la estructura de iteración      
        for (int ciclos = 0; ciclos < cantidadCiclos; ciclos++) {           
            //En caso de haber procesos nuevos se verica la cantidad de procesos en las lista listos, bloqueados, ejecutando 
            //si la cant es menor de 10 se agrega un nuevo procesos a la lista de listos hasta que se alcancen los 10
            while (!colaNuevos.isEmpty()) {
               
                if ((colaListos.size() + colaEjecutando.size() + colaBloqueados.size()) < 10) {
                    colaNuevos.element().setEstado(1);
                    Proceso proceso = colaNuevos.remove();
                    colaListos.add(proceso);
                } else {
                    break;
                }
                
                
            }

            //Verificando si hay procesos en la cola de listos. Si la cola ejecutando está vacía, encola un proceso listo para ejecutarse.
            if (!colaListos.isEmpty()) {
                if (colaEjecutando.isEmpty()) {
                    colaListos.element().setEstado(2);
                    colaEjecutando.add(colaListos.remove());
                }
            }

            //Ejecución de procesos
            if (!colaEjecutando.isEmpty()) {
                //Verificando si la cantidad de instrucciones ejecutadas es distinta a la cantidad de instrucciones del proceso
                if (colaEjecutando.element().getCantInstEjecutadas() != colaEjecutando.element().getCatidadInstruc()) {
                    colaEjecutando.element().AumCantInstEjecutadas();
                    traza = traza +  colaEjecutando.element().toString() + "\n";
                    colaEjecutando.element().aumentarCiclosEjecu();//Se lleva un conteo de cuántos ciclos seguidos se ha ejecutado el proceso.
                    //Verificando si NO se ha llegado a la instrucción de bloqueo
                    if (colaEjecutando.element().getIntrucBloqueo() != colaEjecutando.element().getCantInstEjecutadas()) {
                        //Verificando si el proceso se ejecutó durante 3 segmentos seguidos 
                        if (colaEjecutando.element().getCiclosEjecutando() == 3) {
                            //Si se ha ejecutado el proceso durante 3 segmentos seguidos, se comprueba que su prioridad pueda ser degradada
                            if (colaEjecutando.element().getPrioridad() < 3) {
                                colaEjecutando.element().setPrioridad(colaEjecutando.element().getPrioridad() + 1);
                            }
                            //Se procede a mover el proceso a la cola de listos
                            colaEjecutando.element().setEstado(1);
                            colaEjecutando.element().limpiarCiclosEjecu();
                            colaListos.add(colaEjecutando.remove());
                        }
                    } else {//Si la instrucción de bloqueo es igual a la cantidad de instrucciones ejecutadas, se procede a bloquear el proceso
                        colaEjecutando.element().setEstado(3);
                        colaEjecutando.element().limpiarCiclosEjecu();
                        colaBloqueados.add(colaEjecutando.remove());
                    }
                } else {//Si la cantidad de instrucciones ejecutas es igual a la cantidad de instrucciones del proceso, este se da por terminado 
                    colaEjecutando.element().setEstado(4);
                    colaTerminados.add(colaEjecutando.remove());
                }
            }

            //Verifica que existan procesos bloqueados
            if (!colaBloqueados.isEmpty()) {
                //Copiar la cola de bloqueados en la cola de impresion para poder manipularla
                colaImpresion.addAll(colaBloqueados);
                //Vaciar la cola de bloqueados para poder insertar nuevamente los procesos modificados
                colaBloqueados.clear();
                //Mientras la cola de impresión tenga elementos se aumentará la cantidad de instrucciones ejecutadas de los procesos  
                while (!colaImpresion.isEmpty()) {
                    //Verifica si la cantidad de instrucciones ejecutadas es distinta la instruccion de bloqueo + la cantidad de instrucciones en la que debe permanecer bloqueado el proceso
                    if (colaImpresion.element().getCantInstEjecutadas() != (colaImpresion.element().getIntrucBloqueo() + colaImpresion.element().getCiclosBloqueo())) {
                        //Aumentar la cantidad de instrucciones ejecutadas y retornar el proceso a la cola de bloqueados
                        colaImpresion.element().AumCantInstEjecutadas();
                        colaBloqueados.add(colaImpresion.remove());
                    } else {//Si se han ejecutado las instrucciones del evento de bloque, se procede a encolar el proceso a Listos.
                        colaImpresion.element().setEstado(1);
                        colaListos.add(colaImpresion.remove());
                    }
                }
            }
          
        }
        imprimirColas();
        guardarOrdenEjecucionProcesos(traza);
    }

    public void limpiarColas() {
        //Limpiados los textBox de las colas
        txtcola0.setText("");
        txtcola1.setText("");
        txtcola2.setText("");
        txtcola3.setText("");
        txtcola4.setText("");
        txtHistorialEjecucion.setText("");
        //Limpiando las colas
        colaImpresion.clear();
        colaNuevos.clear();
        colaListos.clear();
        colaEjecutando.clear();
        colaBloqueados.clear();
        colaTerminados.clear();
    }

    public void imprimirColas() {
        txtcola0.setText("");
        txtcola1.setText("");
        txtcola2.setText("");
        txtcola3.setText("");
        txtcola4.setText("");
        //Imprimiendo la cola de nuevos
//        System.out.println("");
//        System.out.println("PROCESOS NUEVOS");
        colaImpresion.addAll(colaNuevos);
        while (!colaImpresion.isEmpty()) {
            Proceso proceso = colaImpresion.remove();//procesos nuevos
//            System.out.println(proceso);
            //Imprime en el textBox correspondiente todos los procesos nuevos
            txtcola0.append(String.valueOf(proceso) + "\n");
        }

        //Imprimiendo la cola de listos
//        System.out.println("");
//        System.out.println("PROCESOS LISTOS");
        colaImpresion.addAll(colaListos);
        while (!colaImpresion.isEmpty()) {
            Proceso proceso = colaImpresion.remove();
//            System.out.println(proceso);
            //Imprime en el textBox correspondiente todos los procesos listos
            txtcola1.append(String.valueOf(proceso) + "\n");
        }

        //Imprimiendo la cola de ejecutando
//        System.out.println("");
//        System.out.println("PROCESOS EJECUTANDO");
        colaImpresion.addAll(colaEjecutando);
        while (!colaImpresion.isEmpty()) {
            Proceso proceso = colaImpresion.remove();
//            System.out.println(proceso);
            //Imprime en el textBox correspondiente todos los procesos ejecutando
            txtcola2.append(String.valueOf(proceso) + "\n");
        }

        //Imprimiendo la cola de bloqueados
//        System.out.println("");
//        System.out.println("PROCESOS BLOQUEADOS");
        colaImpresion.addAll(colaBloqueados);
        while (!colaImpresion.isEmpty()) {
            Proceso proceso = colaImpresion.remove();
//            System.out.println(proceso);
            //Imprime en el textBox correspondiente todos los procesos bloqueados
            txtcola3.append(String.valueOf(proceso) + "\n");
        }

        //Imprimiendo la cola de terminados
//        System.out.println("");
//        System.out.println("PROCESOS TERMINADOS");
        colaImpresion.addAll(colaTerminados);
        while (!colaImpresion.isEmpty()) {
            Proceso proceso = colaImpresion.remove();
//            System.out.println(proceso);
            //Imprime en el textBox correspondiente todos los procesos terminados
            txtcola4.append(String.valueOf(proceso) + "\n");
        }

    }

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */

 /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Formulario().setVisible(true);
            }
        });
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnEjecutar;
    private javax.swing.JButton btnGuardar;
    private javax.swing.JButton btnSimulacion;
    private javax.swing.JButton btnnueva;
    private javax.swing.JDesktopPane jDesktopPane1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JLabel lblCantidad;
    private javax.swing.JLabel lblHistorial;
    private javax.swing.JTextArea txtHistorialEjecucion;
    private javax.swing.JTextField txtcantidad;
    private static javax.swing.JTextArea txtcola0;
    private static javax.swing.JTextArea txtcola1;
    private static javax.swing.JTextArea txtcola2;
    private static javax.swing.JTextArea txtcola3;
    private static javax.swing.JTextArea txtcola4;
    // End of variables declaration//GEN-END:variables

}
